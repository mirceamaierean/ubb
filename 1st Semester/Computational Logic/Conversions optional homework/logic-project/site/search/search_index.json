{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Operations and Conversions This is the documentation for the project Operations and Conversion in different bases, made by M\u0103ierean Mircea. Project layout src/ # The source folder. start.py # The module that you have to run in order to execute the application. ui.py # The module that has the part of the user interaction. It proccesses the input and performs the operations. functions.py # The module that has the functions neccessary to perform these operations. The most important one are documented below. Starting the projects In order to run this project, you have to run start.py Functions For Conversions 1) convert_using_substitution_method Statement: Given a number in base b , convert it to base h using substitution method Usage This method is useful when we convert from a greater base to a smaller one. def convert_using_substitution_method(a, b, h): \"\"\" a: string, the number which we have to convert b: integer, source base h: integer, destination base list_of_digits contains all the suitable digits that can be found in the bases we work with \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" We find the equivalent of b in our digit representation \"\"\" b = list_of_digits[b] index = len(a) - 1 res = \"\" \"\"\" Mult is a string that is going to be multiplied with different digits in order to calculate our required sum \"\"\" mult = \"1\" while index >= 0: \"\"\" We find the current digits of our number. We find the value of our current_number as the product between mult and dig in base h To our result, we add current_number in base h We update the value of mul, by the product of the current value and the corresponding digit to b \"\"\" dig = a[index] current_number = multiply_a_number_to_a_digit_in_base_p(mult, dig, h) res = add_2_numbers_in_base_p(res, current_number, h) mult = multiply_a_number_to_a_digit_in_base_p(mult, b, h) index -= 1 \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(res) > 0 and res[0] == '0': res = res[1:] return res 2) convert_using_successive_divisions_method Statement: Given a number in base b , convert it to base h using successive division method Usage This method is useful when we convert from a smaller base to a greater base, because we have to perform only multiplications and divisions by one digit. def convert_using_successive_divisions_method(a, b, h): \"\"\" a: string, the number which we have to convert b: integer, source base h: integer, destination base list_of_digits contains all the suitable digits that can be found in the bases we work with \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" We find the equivalent of b in our digit representation \"\"\" b = list_of_digits[b] res = \"\" while a != \"0\": \"\"\" At a step, we divide our number a to the digit b in base h The remainder is added at the front of the string res, and we repeat this step as long as a is greater than 0 \"\"\" a, remainder = divide_a_number_to_a_digit_in_base_p(a, b, h) res = list_of_digits[remainder] + res \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(res) > 0 and res[0] == '0': res = res[1:] return res \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(res) > 0 and res[0] == '0': res = res[1:] return res 3) convert_using_base_10_as_intermediary_base Statement: Given a number in base b , convert it to base 10, and after that, convert it to base h Usage This method requires multiple steps, but it is easier to work with because we can perform operations in base 10, that are easier to compute. def convert_using_base_10_as_intermediary_base(a, b, h): \"\"\" a: string, the number we have to convert b: integer, the source base h: integer, the destination base \"\"\" if b == 16: \"\"\" If we have to convert from the base 16, then for sure we will convert to a base smaller than 10 For this type of conversion, it is reccomended to use the successive divisions method We convert from base 16 to 10, and from base 10 to base h \"\"\" result_in_base_10 = convert_using_successive_divisions_method(a, b, 10) return result_in_base_10, convert_using_successive_divisions_method(result_in_base_10, 10, h) if h == 16: \"\"\" If we have to convert to the base 16, then for sure we will convert from a base smaller than 10 For this type of conversion, it is reccomended to use the substitution method We convert from base b to 10, and from base 10 to base 16 \"\"\" result_in_base_10 = convert_using_substitution_method(a, b, 10) return result_in_base_10, convert_using_substitution_method(result_in_base_10, 10, h) \"\"\" For this case, both of our bases are smaller than 10, so: b < 10 => we will convert from base b to base 10 using the substitution method 10 < h => we will convert from base 10 to base h using the successive divisions method \"\"\" result_in_base_10 = convert_using_substitution_method(a, b, 10) return result_in_base_10, convert_using_substitution_method(result_in_base_10, 10, h) 4) rapid_conversion_from_base_2 Statement: Given a number in base 2, convert it to base h , where h is from the set {4, 8, 16} Usage This method is based on a conversion table. We group digits in various numbers, depending on the base to which we convert, we look in the table at the equivalent value, and we use the new group in order to create the new result. def rapid_conversion_from_base_2(a, p): \"\"\" a: string, the number in base 2 p: the base in which we want to convert to \"\"\" \"\"\" Correspondence table is a python dictionary, that has all the equivalent representations for the numbers from 0 to 16 in their corresponding base \"\"\" correspondence_table = { 2: [\"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"], 4: [\"0\", \"1\", \"2\", \"3\", \"10\", \"11\", \"12\", \"13\", \"20\", \"21\", \"22\", \"23\", \"30\", \"31\", \"32\", \"33\"], 8: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"], 16: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], } a_index = len(a) - 1 \"\"\" k represent how many digits we have to take to form a group. EG: For converting to base 8, we have to take 3 at a time \"\"\" k = int(math.log(p, 2)) result = \"\" while a_index >= 0: \"\"\" We loop through the number, from right to left, and group the digits k at a time \"\"\" group = \"\" for _ in range(k): \"\"\" As long as we have digits to take, we add them at the front of our group \"\"\" if a_index >= 0: group = a[a_index] + group a_index -= 1 \"\"\" If we have to complete them, we add 0 at the front of the group \"\"\" while group[0] == '0' and len(group) > 1: group = group[1:] \"\"\" We find the equivalence inside the table \"\"\" result = correspondence_table[p][correspondence_table[2].index(group)] + result return result 5) rapid_conversion_to_base_2 Statement: Given a number in base h , convert it to base 2, where h is from the set {4, 8, 16} Usage This method is based on a conversion table. We group digits in various numbers, depending on the base from which we convert, we look in the table at the equivalent value, and we use the new group in order to create the new result. def rapid_conversion_to_base_2(a, p): \"\"\" a: string, the number in base p p: the base from which we convert \"\"\" \"\"\" Correspondence table is a python dictionary, that has all the equivalent representations for the numbers from 0 to 16 in their corresponding base \"\"\" correspondence_table = { 2: [\"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"], 4: [\"0\", \"1\", \"2\", \"3\", \"10\", \"11\", \"12\", \"13\", \"20\", \"21\", \"22\", \"23\", \"30\", \"31\", \"32\", \"33\"], 8: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"], 16: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], } \"\"\" k represent how many digits are in base 2 from base p in a group EG: For converting from base 8, a digit in base 8 corresponds to 3 digits in base 2 \"\"\" k = int(math.log(p, 2)) a_index = len(a) - 1 result = \"\" while a_index >= 0: \"\"\" We loop inside our number, from left to right. As we take a digit, we find the equivalent representation in base 2 \"\"\" group = correspondence_table[2][correspondence_table[p].index(str(a[a_index]))] a_index -= 1 \"\"\" If the number of digits from the group does not equal k, we ad zeroes at the front until the requirement is satisfied \"\"\" while len(group) < k: group = \"0\" + group result = group + result \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(result) > 1 and result[0] == '0': result = result[1:] return result Functions For Operations 1) add_2_numbers_in_base_p Statement: Given two numbers in base p , find the sum of them. def add_2_numbers_in_base_p(a, b, p): \"\"\" a: string b: string p: integer list_of_digits contains all the suitable digits that can be found in the bases we work with It's easier for us to store the numbers a and b as strings, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] a_index = len(a) - 1 b_index = len(b) - 1 ''' We initialize a value for the remainder, that will be updated by case ''' remainder = 0 result = \"\" while a_index >= 0 or b_index >= 0: ''' We take the digits, pair by pair, of our numbers. Since them are strings, we can find them by the corresponding index. From each one of the numbers, we take the digits as long as their corresponding indexes are non negative numbers ''' digit_of_a = 0; if a_index >= 0: ''' The corresponding value in base 10 is the index of our list_of_digits list ''' digit_of_a = list_of_digits.index(a[a_index]) a_index -= 1 digit_of_b = 0; if b_index >= 0: digit_of_b = list_of_digits.index(b[b_index]) b_index -= 1 ''' We add digits of a, digit of b, and the remainder, we compute the modulus value in base b, and the corresponding digit will be in the list_of_digits at the position of our result After that, the remainder has to be updated, for the future additions, and that value will be the quotient of the division by p EG: digit_of_a = 7, digits_of_b = 8, remainder = 1, p = 16; current_digitst = list_of_digits[(7 + 8 + 1) % 16] = list_of_digits[16 % 16] = list_of_digits[0] = '0' remainder = (7 + 8 + 1) / 16 = 16 / 16 = 1 ''' current_digit_of_number = list_of_digits[(digit_of_a + digit_of_b + remainder) % p] remainder = (digit_of_a + digit_of_b + remainder) // p ''' We add the digit at the front of our result ''' result = current_digit_of_number + result ''' If the remainder is different to 0, we have to add the digit at the front of our result ''' if remainder > 0: current_digit_of_number = list_of_digits[remainder] result = current_digit_of_number + result return result 2) sub_2_numbers_in_base_p Statement: Given two numbers in base p , find the difference of them. def sub_2_numbers_in_base_p(a, b, p): \"\"\" a: string b: string p: integer list_of_digits contains all the suitable digits that can be found in the bases we work with It's easier for us to store the numbers a and b as strings, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" For the case in which the first number is smaller than the second one, we swap them, and we mark in sgn that the result will be a negative number \"\"\" a, b, sgn = greater_numbers(a, b) a_index = len(a) - 1 b_index = len(b) - 1 ''' We initialize a value to mark the we borrow from the next diigts, that will be updated by case ''' borrow = 0 result = \"\" while a_index >= 0: ''' We take the digits, pair by pair, of our numbers. Since them are strings, we can find them by the corresponding index. From each one of the numbers, we take the digits as long as their corresponding indexes are non negative numbers ''' ''' The corresponding value in base 10 is the index of our list_of_digits list. In case we borrow from another digit, we subtract one from our current digit ''' digit_of_a = list_of_digits.index(a[a_index]) - borrow if digit_of_a <= 0: \"\"\" If our result is smaller than 0, then it means that we will have the digit p - borrow. The value of borrow does not change \"\"\" digit_of_a = p - borrow borrow = 1 else: borrow = 0 a_index -= 1 digit_of_b = 0; if b_index >= 0: digit_of_b = list_of_digits.index(b[b_index]) b_index -= 1 if digit_of_a < digit_of_b: \"\"\" In this case, we have to borrow \"\"\" digit_of_a += p borrow = 1 \"\"\" The corresponding digit is found at the position digit_of_a - digit_of_b in our list \"\"\" current_digit_of_number = list_of_digits[digit_of_a - digit_of_b] ''' We add the digit at the front of our result ''' result = current_digit_of_number + result \"\"\" As long as our number exists, and the first digit of the result is 0, we remove it. \"\"\" while result[0] == '0' and len(result) > 1: result = result[1:] \"\"\" If necessary, we add the sign at the front of the result \"\"\" result = sgn + result return result 3) multiply_a_number_to_a_digit_in_base_p Statement: Given a numbers nr in base p , and a digit dig , in the same base, multiply nr with dig . def multiply_a_number_to_a_digit_in_base_p(nr, dig, p): \"\"\" nr: string, dig: character with which the first number is multiplied p: integer, the base of the number list_of_digits contains all the suitable digits that can be found in the bases we work with It's easier for us to store the number nr as string, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] index = len(nr) - 1 \"\"\" We find the equivalent in base 10 of our digit, being the index of the digit's value \"\"\" dig = list_of_digits.index(dig) result = \"\" ''' We initialize a value for the remainder, that will be updated by case ''' remainder = 0 while index >= 0: ''' We take the digits, from right to left, of our number. Since it is a string, we can find it by the corresponding index. We take the digits as long as the indexe is positive ''' digit_of_nr = list_of_digits.index(nr[index]) index -= 1 \"\"\" We multiply the current digit of the number with dig, we add the remainder from the previous step, and we find the corresponding value in list_of_digits as the reminder of the division to p. We update what we have to add for the next step \"\"\" current_digit_of_number = list_of_digits[(digit_of_nr * dig + remainder) % p] remainder = (digit_of_nr * dig + remainder) // p result = current_digit_of_number + result \"\"\" If we still have to add, we'll add the remainder at the front of our result \"\"\" if remainder > 0: current_digit_of_number = list_of_digits[remainder] result = current_digit_of_number + result return result 4) divide_a_number_to_a_digit_in_base_p Statement: Given a numbers nr in base p , and a digit dig , in the same base, divide nr to dig , and display the result of the division and the remainder . def divide_a_number_to_a_digit_in_base_p(nr, dig, p): \"\"\" nr: string, dig: character with which the first number is divided p: integer, the base of the number list_of_digits contains all the suitable digits that can be found in the bases we work woth It's easier for us to store the number nr as string, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" We find the equivalent in base 10 of our digit, being the index of the digit's value \"\"\" dig = list_of_digits.index(dig) result = \"\" ''' We initialize a value for the remainder, that will be updated by case ''' remainder = 0 for digit_of_nr in nr: \"\"\" We loop through the digits from left to right, taking one each at a time. We find the corresponding value in base 10. We compute the value remainder * p + digit_of_nr, and we divide if to dig, taking the integer part. We find the corresponding character of this number, and add it at the end of the result We update the remainder as the result of the previous operation % p \"\"\" digit_of_nr = list_of_digits.index(digit_of_nr) current_digit_of_number = list_of_digits[(remainder * p + digit_of_nr) // dig] remainder = (remainder * p + digit_of_nr) % dig result = result + current_digit_of_number \"\"\" As long as our result exists, and the first digit is 0, we remove it \"\"\" while result[0] == '0' and len(result) > 1: result = result[1:] \"\"\" We return the result, and the remainder of this division \"\"\" return result, remainder","title":"Welcome to Operations and Conversions"},{"location":"#welcome-to-operations-and-conversions","text":"This is the documentation for the project Operations and Conversion in different bases, made by M\u0103ierean Mircea.","title":"Welcome to Operations and Conversions"},{"location":"#project-layout","text":"src/ # The source folder. start.py # The module that you have to run in order to execute the application. ui.py # The module that has the part of the user interaction. It proccesses the input and performs the operations. functions.py # The module that has the functions neccessary to perform these operations. The most important one are documented below.","title":"Project layout"},{"location":"#starting-the-projects","text":"In order to run this project, you have to run start.py","title":"Starting the projects"},{"location":"#functions-for-conversions","text":"","title":"Functions For Conversions"},{"location":"#1-convert_using_substitution_method","text":"","title":"1) convert_using_substitution_method"},{"location":"#statement-given-a-number-in-base-b-convert-it-to-base-h-using-substitution-method","text":"","title":"Statement: Given a number in base b, convert it to base h using substitution method"},{"location":"#usage","text":"This method is useful when we convert from a greater base to a smaller one. def convert_using_substitution_method(a, b, h): \"\"\" a: string, the number which we have to convert b: integer, source base h: integer, destination base list_of_digits contains all the suitable digits that can be found in the bases we work with \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" We find the equivalent of b in our digit representation \"\"\" b = list_of_digits[b] index = len(a) - 1 res = \"\" \"\"\" Mult is a string that is going to be multiplied with different digits in order to calculate our required sum \"\"\" mult = \"1\" while index >= 0: \"\"\" We find the current digits of our number. We find the value of our current_number as the product between mult and dig in base h To our result, we add current_number in base h We update the value of mul, by the product of the current value and the corresponding digit to b \"\"\" dig = a[index] current_number = multiply_a_number_to_a_digit_in_base_p(mult, dig, h) res = add_2_numbers_in_base_p(res, current_number, h) mult = multiply_a_number_to_a_digit_in_base_p(mult, b, h) index -= 1 \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(res) > 0 and res[0] == '0': res = res[1:] return res","title":"Usage"},{"location":"#2-convert_using_successive_divisions_method","text":"","title":"2) convert_using_successive_divisions_method"},{"location":"#statement-given-a-number-in-base-b-convert-it-to-base-h-using-successive-division-method","text":"","title":"Statement: Given a number in base b, convert it to base h using successive division method"},{"location":"#usage_1","text":"This method is useful when we convert from a smaller base to a greater base, because we have to perform only multiplications and divisions by one digit. def convert_using_successive_divisions_method(a, b, h): \"\"\" a: string, the number which we have to convert b: integer, source base h: integer, destination base list_of_digits contains all the suitable digits that can be found in the bases we work with \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" We find the equivalent of b in our digit representation \"\"\" b = list_of_digits[b] res = \"\" while a != \"0\": \"\"\" At a step, we divide our number a to the digit b in base h The remainder is added at the front of the string res, and we repeat this step as long as a is greater than 0 \"\"\" a, remainder = divide_a_number_to_a_digit_in_base_p(a, b, h) res = list_of_digits[remainder] + res \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(res) > 0 and res[0] == '0': res = res[1:] return res \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(res) > 0 and res[0] == '0': res = res[1:] return res","title":"Usage"},{"location":"#3-convert_using_base_10_as_intermediary_base","text":"","title":"3) convert_using_base_10_as_intermediary_base"},{"location":"#statement-given-a-number-in-base-b-convert-it-to-base-10-and-after-that-convert-it-to-base-h","text":"","title":"Statement: Given a number in base b, convert it to base 10, and after that, convert it to base h"},{"location":"#usage_2","text":"This method requires multiple steps, but it is easier to work with because we can perform operations in base 10, that are easier to compute. def convert_using_base_10_as_intermediary_base(a, b, h): \"\"\" a: string, the number we have to convert b: integer, the source base h: integer, the destination base \"\"\" if b == 16: \"\"\" If we have to convert from the base 16, then for sure we will convert to a base smaller than 10 For this type of conversion, it is reccomended to use the successive divisions method We convert from base 16 to 10, and from base 10 to base h \"\"\" result_in_base_10 = convert_using_successive_divisions_method(a, b, 10) return result_in_base_10, convert_using_successive_divisions_method(result_in_base_10, 10, h) if h == 16: \"\"\" If we have to convert to the base 16, then for sure we will convert from a base smaller than 10 For this type of conversion, it is reccomended to use the substitution method We convert from base b to 10, and from base 10 to base 16 \"\"\" result_in_base_10 = convert_using_substitution_method(a, b, 10) return result_in_base_10, convert_using_substitution_method(result_in_base_10, 10, h) \"\"\" For this case, both of our bases are smaller than 10, so: b < 10 => we will convert from base b to base 10 using the substitution method 10 < h => we will convert from base 10 to base h using the successive divisions method \"\"\" result_in_base_10 = convert_using_substitution_method(a, b, 10) return result_in_base_10, convert_using_substitution_method(result_in_base_10, 10, h)","title":"Usage"},{"location":"#4-rapid_conversion_from_base_2","text":"","title":"4) rapid_conversion_from_base_2"},{"location":"#statement-given-a-number-in-base-2-convert-it-to-base-h-where-h-is-from-the-set-4-8-16","text":"","title":"Statement: Given a number in base 2, convert it to base h, where h is from the set {4, 8, 16}"},{"location":"#usage_3","text":"This method is based on a conversion table. We group digits in various numbers, depending on the base to which we convert, we look in the table at the equivalent value, and we use the new group in order to create the new result. def rapid_conversion_from_base_2(a, p): \"\"\" a: string, the number in base 2 p: the base in which we want to convert to \"\"\" \"\"\" Correspondence table is a python dictionary, that has all the equivalent representations for the numbers from 0 to 16 in their corresponding base \"\"\" correspondence_table = { 2: [\"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"], 4: [\"0\", \"1\", \"2\", \"3\", \"10\", \"11\", \"12\", \"13\", \"20\", \"21\", \"22\", \"23\", \"30\", \"31\", \"32\", \"33\"], 8: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"], 16: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], } a_index = len(a) - 1 \"\"\" k represent how many digits we have to take to form a group. EG: For converting to base 8, we have to take 3 at a time \"\"\" k = int(math.log(p, 2)) result = \"\" while a_index >= 0: \"\"\" We loop through the number, from right to left, and group the digits k at a time \"\"\" group = \"\" for _ in range(k): \"\"\" As long as we have digits to take, we add them at the front of our group \"\"\" if a_index >= 0: group = a[a_index] + group a_index -= 1 \"\"\" If we have to complete them, we add 0 at the front of the group \"\"\" while group[0] == '0' and len(group) > 1: group = group[1:] \"\"\" We find the equivalence inside the table \"\"\" result = correspondence_table[p][correspondence_table[2].index(group)] + result return result","title":"Usage"},{"location":"#5-rapid_conversion_to_base_2","text":"","title":"5) rapid_conversion_to_base_2"},{"location":"#statement-given-a-number-in-base-h-convert-it-to-base-2-where-h-is-from-the-set-4-8-16","text":"","title":"Statement: Given a number in base h, convert it to base 2, where h is from the set {4, 8, 16}"},{"location":"#usage_4","text":"This method is based on a conversion table. We group digits in various numbers, depending on the base from which we convert, we look in the table at the equivalent value, and we use the new group in order to create the new result. def rapid_conversion_to_base_2(a, p): \"\"\" a: string, the number in base p p: the base from which we convert \"\"\" \"\"\" Correspondence table is a python dictionary, that has all the equivalent representations for the numbers from 0 to 16 in their corresponding base \"\"\" correspondence_table = { 2: [\"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\", \"1101\", \"1110\", \"1111\"], 4: [\"0\", \"1\", \"2\", \"3\", \"10\", \"11\", \"12\", \"13\", \"20\", \"21\", \"22\", \"23\", \"30\", \"31\", \"32\", \"33\"], 8: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\"], 16: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"], } \"\"\" k represent how many digits are in base 2 from base p in a group EG: For converting from base 8, a digit in base 8 corresponds to 3 digits in base 2 \"\"\" k = int(math.log(p, 2)) a_index = len(a) - 1 result = \"\" while a_index >= 0: \"\"\" We loop inside our number, from left to right. As we take a digit, we find the equivalent representation in base 2 \"\"\" group = correspondence_table[2][correspondence_table[p].index(str(a[a_index]))] a_index -= 1 \"\"\" If the number of digits from the group does not equal k, we ad zeroes at the front until the requirement is satisfied \"\"\" while len(group) < k: group = \"0\" + group result = group + result \"\"\" In case we have leading zeroes at the front of our result, we erase them \"\"\" while len(result) > 1 and result[0] == '0': result = result[1:] return result","title":"Usage"},{"location":"#functions-for-operations","text":"","title":"Functions For Operations"},{"location":"#1-add_2_numbers_in_base_p","text":"","title":"1) add_2_numbers_in_base_p"},{"location":"#statement-given-two-numbers-in-base-p-find-the-sum-of-them","text":"def add_2_numbers_in_base_p(a, b, p): \"\"\" a: string b: string p: integer list_of_digits contains all the suitable digits that can be found in the bases we work with It's easier for us to store the numbers a and b as strings, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] a_index = len(a) - 1 b_index = len(b) - 1 ''' We initialize a value for the remainder, that will be updated by case ''' remainder = 0 result = \"\" while a_index >= 0 or b_index >= 0: ''' We take the digits, pair by pair, of our numbers. Since them are strings, we can find them by the corresponding index. From each one of the numbers, we take the digits as long as their corresponding indexes are non negative numbers ''' digit_of_a = 0; if a_index >= 0: ''' The corresponding value in base 10 is the index of our list_of_digits list ''' digit_of_a = list_of_digits.index(a[a_index]) a_index -= 1 digit_of_b = 0; if b_index >= 0: digit_of_b = list_of_digits.index(b[b_index]) b_index -= 1 ''' We add digits of a, digit of b, and the remainder, we compute the modulus value in base b, and the corresponding digit will be in the list_of_digits at the position of our result After that, the remainder has to be updated, for the future additions, and that value will be the quotient of the division by p EG: digit_of_a = 7, digits_of_b = 8, remainder = 1, p = 16; current_digitst = list_of_digits[(7 + 8 + 1) % 16] = list_of_digits[16 % 16] = list_of_digits[0] = '0' remainder = (7 + 8 + 1) / 16 = 16 / 16 = 1 ''' current_digit_of_number = list_of_digits[(digit_of_a + digit_of_b + remainder) % p] remainder = (digit_of_a + digit_of_b + remainder) // p ''' We add the digit at the front of our result ''' result = current_digit_of_number + result ''' If the remainder is different to 0, we have to add the digit at the front of our result ''' if remainder > 0: current_digit_of_number = list_of_digits[remainder] result = current_digit_of_number + result return result","title":"Statement: Given two numbers in base p, find the sum of them."},{"location":"#2-sub_2_numbers_in_base_p","text":"","title":"2) sub_2_numbers_in_base_p"},{"location":"#statement-given-two-numbers-in-base-p-find-the-difference-of-them","text":"def sub_2_numbers_in_base_p(a, b, p): \"\"\" a: string b: string p: integer list_of_digits contains all the suitable digits that can be found in the bases we work with It's easier for us to store the numbers a and b as strings, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" For the case in which the first number is smaller than the second one, we swap them, and we mark in sgn that the result will be a negative number \"\"\" a, b, sgn = greater_numbers(a, b) a_index = len(a) - 1 b_index = len(b) - 1 ''' We initialize a value to mark the we borrow from the next diigts, that will be updated by case ''' borrow = 0 result = \"\" while a_index >= 0: ''' We take the digits, pair by pair, of our numbers. Since them are strings, we can find them by the corresponding index. From each one of the numbers, we take the digits as long as their corresponding indexes are non negative numbers ''' ''' The corresponding value in base 10 is the index of our list_of_digits list. In case we borrow from another digit, we subtract one from our current digit ''' digit_of_a = list_of_digits.index(a[a_index]) - borrow if digit_of_a <= 0: \"\"\" If our result is smaller than 0, then it means that we will have the digit p - borrow. The value of borrow does not change \"\"\" digit_of_a = p - borrow borrow = 1 else: borrow = 0 a_index -= 1 digit_of_b = 0; if b_index >= 0: digit_of_b = list_of_digits.index(b[b_index]) b_index -= 1 if digit_of_a < digit_of_b: \"\"\" In this case, we have to borrow \"\"\" digit_of_a += p borrow = 1 \"\"\" The corresponding digit is found at the position digit_of_a - digit_of_b in our list \"\"\" current_digit_of_number = list_of_digits[digit_of_a - digit_of_b] ''' We add the digit at the front of our result ''' result = current_digit_of_number + result \"\"\" As long as our number exists, and the first digit of the result is 0, we remove it. \"\"\" while result[0] == '0' and len(result) > 1: result = result[1:] \"\"\" If necessary, we add the sign at the front of the result \"\"\" result = sgn + result return result","title":"Statement: Given two numbers in base p, find the difference of them."},{"location":"#3-multiply_a_number_to_a_digit_in_base_p","text":"","title":"3) multiply_a_number_to_a_digit_in_base_p"},{"location":"#statement-given-a-numbers-nr-in-base-p-and-a-digit-dig-in-the-same-base-multiply-nr-with-dig","text":"def multiply_a_number_to_a_digit_in_base_p(nr, dig, p): \"\"\" nr: string, dig: character with which the first number is multiplied p: integer, the base of the number list_of_digits contains all the suitable digits that can be found in the bases we work with It's easier for us to store the number nr as string, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] index = len(nr) - 1 \"\"\" We find the equivalent in base 10 of our digit, being the index of the digit's value \"\"\" dig = list_of_digits.index(dig) result = \"\" ''' We initialize a value for the remainder, that will be updated by case ''' remainder = 0 while index >= 0: ''' We take the digits, from right to left, of our number. Since it is a string, we can find it by the corresponding index. We take the digits as long as the indexe is positive ''' digit_of_nr = list_of_digits.index(nr[index]) index -= 1 \"\"\" We multiply the current digit of the number with dig, we add the remainder from the previous step, and we find the corresponding value in list_of_digits as the reminder of the division to p. We update what we have to add for the next step \"\"\" current_digit_of_number = list_of_digits[(digit_of_nr * dig + remainder) % p] remainder = (digit_of_nr * dig + remainder) // p result = current_digit_of_number + result \"\"\" If we still have to add, we'll add the remainder at the front of our result \"\"\" if remainder > 0: current_digit_of_number = list_of_digits[remainder] result = current_digit_of_number + result return result","title":"Statement: Given a numbers nr in base p, and a digit dig, in the same base, multiply nr with dig."},{"location":"#4-divide_a_number_to_a_digit_in_base_p","text":"","title":"4) divide_a_number_to_a_digit_in_base_p"},{"location":"#statement-given-a-numbers-nr-in-base-p-and-a-digit-dig-in-the-same-base-divide-nr-to-dig-and-display-the-result-of-the-division-and-the-remainder","text":"def divide_a_number_to_a_digit_in_base_p(nr, dig, p): \"\"\" nr: string, dig: character with which the first number is divided p: integer, the base of the number list_of_digits contains all the suitable digits that can be found in the bases we work woth It's easier for us to store the number nr as string, because we will work with the last digit, one by one \"\"\" list_of_digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] \"\"\" We find the equivalent in base 10 of our digit, being the index of the digit's value \"\"\" dig = list_of_digits.index(dig) result = \"\" ''' We initialize a value for the remainder, that will be updated by case ''' remainder = 0 for digit_of_nr in nr: \"\"\" We loop through the digits from left to right, taking one each at a time. We find the corresponding value in base 10. We compute the value remainder * p + digit_of_nr, and we divide if to dig, taking the integer part. We find the corresponding character of this number, and add it at the end of the result We update the remainder as the result of the previous operation % p \"\"\" digit_of_nr = list_of_digits.index(digit_of_nr) current_digit_of_number = list_of_digits[(remainder * p + digit_of_nr) // dig] remainder = (remainder * p + digit_of_nr) % dig result = result + current_digit_of_number \"\"\" As long as our result exists, and the first digit is 0, we remove it \"\"\" while result[0] == '0' and len(result) > 1: result = result[1:] \"\"\" We return the result, and the remainder of this division \"\"\" return result, remainder","title":"Statement: Given a numbers nr in base p, and a digit dig, in the same base, divide nr to dig, and display the result of the division and the remainder ."}]}